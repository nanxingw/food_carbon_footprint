<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D地球食物运输可视化 - 舌尖上的足迹</title>
    <link rel="stylesheet" href="css/style.css">
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background: #000011;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
        }

        #canvas-container {
            width: 100vw;
            height: 100vh;
            position: relative;
        }

        /* 控制面板 */
        .control-panel {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.8);
            border: 1px solid rgba(76, 175, 80, 0.5);
            border-radius: 10px;
            padding: 20px;
            color: white;
            max-width: 350px;
            backdrop-filter: blur(10px);
            box-shadow: 0 0 30px rgba(76, 175, 80, 0.3);
            transition: transform 0.3s ease;
        }

        .control-panel:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 40px rgba(76, 175, 80, 0.4);
        }

        .control-panel h2 {
            margin: 0 0 20px 0;
            color: #4caf50;
            font-size: 24px;
            text-shadow: 0 0 10px rgba(76, 175, 80, 0.5);
        }

        /* 选择器样式 */
        .control-group {
            margin-bottom: 20px;
        }

        .control-group label {
            display: block;
            margin-bottom: 8px;
            color: #81c784;
            font-weight: 500;
        }

        .control-group select {
            width: 100%;
            padding: 10px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(76, 175, 80, 0.5);
            border-radius: 5px;
            color: white;
            font-size: 14px;
            transition: all 0.3s ease;
        }

        .control-group select:hover {
            background: rgba(255, 255, 255, 0.15);
            border-color: #4caf50;
        }

        .control-group select:focus {
            outline: none;
            border-color: #4caf50;
            box-shadow: 0 0 10px rgba(76, 175, 80, 0.5);
        }

        /* 信息显示 */
        .info-display {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 8px;
            padding: 15px;
            margin-top: 20px;
        }

        .info-item {
            display: flex;
            justify-content: space-between;
            margin-bottom: 10px;
            font-size: 14px;
        }

        .info-label {
            color: #aaa;
        }

        .info-value {
            color: #4caf50;
            font-weight: 600;
        }

        /* 图例 */
        .legend {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.8);
            border: 1px solid rgba(76, 175, 80, 0.5);
            border-radius: 10px;
            padding: 15px;
            color: white;
            backdrop-filter: blur(10px);
        }

        .legend h3 {
            margin: 0 0 10px 0;
            color: #4caf50;
            font-size: 16px;
        }

        .legend-item {
            display: flex;
            align-items: center;
            margin-bottom: 8px;
            font-size: 14px;
        }

        .legend-color {
            width: 20px;
            height: 3px;
            margin-right: 10px;
            box-shadow: 0 0 5px currentColor;
        }

        /* 加载动画 */
        .loading-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000011;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            transition: opacity 1s ease;
        }

        .loading-spinner {
            width: 80px;
            height: 80px;
            border: 3px solid rgba(76, 175, 80, 0.3);
            border-top: 3px solid #4caf50;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-bottom: 20px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .loading-text {
            color: #4caf50;
            font-size: 18px;
            animation: pulse 2s ease-in-out infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 0.5; }
            50% { opacity: 1; }
        }

        /* 实时数据面板 */
        .realtime-panel {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.8);
            border: 1px solid rgba(255, 152, 0, 0.5);
            border-radius: 10px;
            padding: 20px;
            color: white;
            max-width: 300px;
            backdrop-filter: blur(10px);
            box-shadow: 0 0 30px rgba(255, 152, 0, 0.3);
        }

        .realtime-panel h3 {
            margin: 0 0 15px 0;
            color: #ff9800;
            font-size: 18px;
            text-shadow: 0 0 10px rgba(255, 152, 0, 0.5);
        }

        .vessel-item {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 5px;
            padding: 10px;
            margin-bottom: 10px;
            border-left: 3px solid #ff9800;
            font-size: 13px;
        }

        .vessel-type {
            color: #ffb74d;
            font-weight: 600;
        }

        .vessel-cargo {
            color: #aaa;
            font-size: 12px;
        }

        /* 返回按钮 */
        .back-button {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: linear-gradient(135deg, #2e7d32 0%, #4caf50 100%);
            color: white;
            padding: 12px 30px;
            border-radius: 25px;
            text-decoration: none;
            font-weight: 600;
            font-size: 16px;
            transition: all 0.3s ease;
            box-shadow: 0 3px 10px rgba(76, 175, 80, 0.3);
            z-index: 100;
        }

        .back-button:hover {
            transform: translateX(-50%) translateY(-2px);
            box-shadow: 0 5px 20px rgba(76, 175, 80, 0.4);
            background: linear-gradient(135deg, #1b5e20 0%, #388e3c 100%);
        }

        /* 碳排放计数器 */
        .carbon-counter {
            position: absolute;
            bottom: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.8);
            border: 1px solid rgba(244, 67, 54, 0.5);
            border-radius: 10px;
            padding: 20px;
            color: white;
            backdrop-filter: blur(10px);
            text-align: center;
        }

        .carbon-counter h3 {
            margin: 0 0 10px 0;
            color: #f44336;
            font-size: 16px;
        }

        .carbon-value {
            font-size: 36px;
            font-weight: bold;
            color: #ff5252;
            text-shadow: 0 0 20px rgba(244, 67, 54, 0.5);
        }

        .carbon-unit {
            font-size: 14px;
            color: #aaa;
        }
    </style>
</head>
<body>
    <!-- 加载画面 -->
    <div class="loading-screen" id="loading-screen">
        <div class="loading-spinner"></div>
        <div class="loading-text">正在初始化3D地球...</div>
    </div>

    <!-- 返回按钮 -->
    <a href="index.html" class="back-button">🏠 返回主导航页</a>

    <!-- 3D画布容器 -->
    <div id="canvas-container"></div>

    <!-- 控制面板 -->
    <div class="control-panel">
        <h2>🌍 食物运输路线</h2>
        <div class="control-group">
            <label for="route-select">选择运输路线：</label>
            <select id="route-select">
                <option value="">--请选择路线--</option>
            </select>
        </div>
        <div class="control-group">
            <label for="speed-control">动画速度：</label>
            <input type="range" id="speed-control" min="0.1" max="3" step="0.1" value="1" 
                   style="width: 100%;">
        </div>
        <div class="info-display" id="route-info">
            <div class="info-item">
                <span class="info-label">路线：</span>
                <span class="info-value" id="route-name">-</span>
            </div>
            <div class="info-item">
                <span class="info-label">运输方式：</span>
                <span class="info-value" id="transport-mode">-</span>
            </div>
            <div class="info-item">
                <span class="info-label">货物类型：</span>
                <span class="info-value" id="cargo-type">-</span>
            </div>
            <div class="info-item">
                <span class="info-label">总距离：</span>
                <span class="info-value" id="total-distance">-</span>
            </div>
            <div class="info-item">
                <span class="info-label">碳排放：</span>
                <span class="info-value" id="carbon-emission">-</span>
            </div>
        </div>
    </div>

    <!-- 图例 -->
    <div class="legend">
        <h3>运输方式</h3>
        <div class="legend-item">
            <div class="legend-color" style="background: #00ff00; color: #00ff00;"></div>
            <span>🚢 海运（低碳）</span>
        </div>
        <div class="legend-item">
            <div class="legend-color" style="background: #ffff00; color: #ffff00;"></div>
            <span>🚚 陆运（中碳）</span>
        </div>
        <div class="legend-item">
            <div class="legend-color" style="background: #ff0000; color: #ff0000;"></div>
            <span>✈️ 空运（高碳）</span>
        </div>
    </div>

    <!-- 实时运输工具面板 -->
    <div class="realtime-panel">
        <h3>📡 实时运输监控</h3>
        <div id="vessels-list"></div>
    </div>

    <!-- 碳排放计数器 -->
    <div class="carbon-counter">
        <h3>累计碳排放</h3>
        <div class="carbon-value" id="total-carbon">0</div>
        <div class="carbon-unit">吨 CO₂</div>
    </div>

    <!-- 引入Three.js和其他依赖 -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // OrbitControls 需要在 Three.js 加载后手动定义
        THREE.OrbitControls = function ( object, domElement ) {
            
            if ( domElement === undefined ) console.warn( 'THREE.OrbitControls: The second parameter "domElement" is now mandatory.' );
            if ( domElement === document ) console.error( 'THREE.OrbitControls: "document" should not be used as the target "domElement". Please use "renderer.domElement" instead.' );

            this.object = object;
            this.domElement = domElement;
            this.domElement.style.touchAction = 'none';

            this.enabled = true;
            this.target = new THREE.Vector3();

            this.minDistance = 0;
            this.maxDistance = Infinity;
            this.minZoom = 0;
            this.maxZoom = Infinity;
            this.minPolarAngle = 0;
            this.maxPolarAngle = Math.PI;
            this.minAzimuthAngle = - Infinity;
            this.maxAzimuthAngle = Infinity;
            this.enableDamping = false;
            this.dampingFactor = 0.05;
            this.enableZoom = true;
            this.zoomSpeed = 1.0;
            this.enableRotate = true;
            this.rotateSpeed = 1.0;
            this.enablePan = true;
            this.panSpeed = 1.0;
            this.screenSpacePanning = true;
            this.keyPanSpeed = 7.0;
            this.autoRotate = false;
            this.autoRotateSpeed = 2.0;
            this.keys = { LEFT: 37, UP: 38, RIGHT: 39, BOTTOM: 40 };
            this.mouseButtons = { LEFT: THREE.MOUSE.ROTATE, MIDDLE: THREE.MOUSE.DOLLY, RIGHT: THREE.MOUSE.PAN };
            this.touches = { ONE: THREE.TOUCH.ROTATE, TWO: THREE.TOUCH.DOLLY_PAN };
            this.target0 = this.target.clone();
            this.position0 = this.object.position.clone();
            this.zoom0 = this.object.zoom;
            this.getPolarAngle = function () {
                return spherical.phi;
            };
            this.getAzimuthalAngle = function () {
                return spherical.theta;
            };
            this.saveState = function () {
                scope.target0.copy( scope.target );
                scope.position0.copy( scope.object.position );
                scope.zoom0 = scope.object.zoom;
            };
            this.reset = function () {
                scope.target.copy( scope.target0 );
                scope.object.position.copy( scope.position0 );
                scope.object.zoom = scope.zoom0;
                scope.object.updateProjectionMatrix();
                scope.dispatchEvent( changeEvent );
                scope.update();
                state = STATE.NONE;
            };
            this.update = function() {
                var offset = new THREE.Vector3();
                var quat = new THREE.Quaternion().setFromUnitVectors( object.up, new THREE.Vector3( 0, 1, 0 ) );
                var quatInverse = quat.clone().invert();
                var lastPosition = new THREE.Vector3();
                var lastQuaternion = new THREE.Quaternion();
                return function update() {
                    var position = scope.object.position;
                    offset.copy( position ).sub( scope.target );
                    offset.applyQuaternion( quat );
                    spherical.setFromVector3( offset );
                    if ( scope.autoRotate && state === STATE.NONE ) {
                        rotateLeft( getAutoRotationAngle() );
                    }
                    if ( scope.enableDamping ) {
                        spherical.theta += sphericalDelta.theta * scope.dampingFactor;
                        spherical.phi += sphericalDelta.phi * scope.dampingFactor;
                    } else {
                        spherical.theta += sphericalDelta.theta;
                        spherical.phi += sphericalDelta.phi;
                    }
                    var min = scope.minAzimuthAngle;
                    var max = scope.maxAzimuthAngle;
                    if ( isFinite( min ) && isFinite( max ) ) {
                        if ( min < - Math.PI ) min += twoPI; else if ( min > Math.PI ) min -= twoPI;
                        if ( max < - Math.PI ) max += twoPI; else if ( max > Math.PI ) max -= twoPI;
                        if ( min <= max ) {
                            spherical.theta = Math.max( min, Math.min( max, spherical.theta ) );
                        } else {
                            spherical.theta = ( spherical.theta > ( min + max ) / 2 ) ?
                                Math.max( min, spherical.theta ) :
                                Math.min( max, spherical.theta );
                        }
                    }
                    spherical.phi = Math.max( scope.minPolarAngle, Math.min( scope.maxPolarAngle, spherical.phi ) );
                    spherical.makeSafe();
                    spherical.radius *= scale;
                    spherical.radius = Math.max( scope.minDistance, Math.min( scope.maxDistance, spherical.radius ) );
                    if ( scope.enableDamping === true ) {
                        scope.target.addScaledVector( panOffset, scope.dampingFactor );
                    } else {
                        scope.target.add( panOffset );
                    }
                    offset.setFromSpherical( spherical );
                    offset.applyQuaternion( quatInverse );
                    position.copy( scope.target ).add( offset );
                    scope.object.lookAt( scope.target );
                    if ( scope.enableDamping === true ) {
                        sphericalDelta.theta *= ( 1 - scope.dampingFactor );
                        sphericalDelta.phi *= ( 1 - scope.dampingFactor );
                        panOffset.multiplyScalar( 1 - scope.dampingFactor );
                    } else {
                        sphericalDelta.set( 0, 0, 0 );
                        panOffset.set( 0, 0, 0 );
                    }
                    scale = 1;
                    if ( zoomChanged ||
                        lastPosition.distanceToSquared( scope.object.position ) > EPS ||
                        8 * ( 1 - lastQuaternion.dot( scope.object.quaternion ) ) > EPS ) {
                        scope.dispatchEvent( changeEvent );
                        lastPosition.copy( scope.object.position );
                        lastQuaternion.copy( scope.object.quaternion );
                        zoomChanged = false;
                        return true;
                    }
                    return false;
                };
            }();
            this.dispose = function () {
                scope.domElement.removeEventListener( 'contextmenu', onContextMenu, false );
                scope.domElement.removeEventListener( 'pointerdown', onPointerDown, false );
                scope.domElement.removeEventListener( 'wheel', onMouseWheel, false );
                scope.domElement.removeEventListener( 'touchstart', onTouchStart, false );
                scope.domElement.removeEventListener( 'touchend', onTouchEnd, false );
                scope.domElement.removeEventListener( 'touchmove', onTouchMove, false );
                scope.domElement.ownerDocument.removeEventListener( 'pointermove', onPointerMove, false );
                scope.domElement.ownerDocument.removeEventListener( 'pointerup', onPointerUp, false );
                scope.domElement.removeEventListener( 'keydown', onKeyDown, false );
            };
            var scope = this;
            var changeEvent = { type: 'change' };
            var startEvent = { type: 'start' };
            var endEvent = { type: 'end' };
            var STATE = {
                NONE: - 1,
                ROTATE: 0,
                DOLLY: 1,
                PAN: 2,
                TOUCH_ROTATE: 3,
                TOUCH_PAN: 4,
                TOUCH_DOLLY_PAN: 5,
                TOUCH_DOLLY_ROTATE: 6
            };
            var state = STATE.NONE;
            var EPS = 0.000001;
            var spherical = new THREE.Spherical();
            var sphericalDelta = new THREE.Spherical();
            var scale = 1;
            var panOffset = new THREE.Vector3();
            var zoomChanged = false;
            var rotateStart = new THREE.Vector2();
            var rotateEnd = new THREE.Vector2();
            var rotateDelta = new THREE.Vector2();
            var panStart = new THREE.Vector2();
            var panEnd = new THREE.Vector2();
            var panDelta = new THREE.Vector2();
            var dollyStart = new THREE.Vector2();
            var dollyEnd = new THREE.Vector2();
            var dollyDelta = new THREE.Vector2();
            function getAutoRotationAngle() {
                return 2 * Math.PI / 60 / 60 * scope.autoRotateSpeed;
            }
            function getZoomScale() {
                return Math.pow( 0.95, scope.zoomSpeed );
            }
            function rotateLeft( angle ) {
                sphericalDelta.theta -= angle;
            }
            function rotateUp( angle ) {
                sphericalDelta.phi -= angle;
            }
            var panLeft = function() {
                var v = new THREE.Vector3();
                return function panLeft( distance, objectMatrix ) {
                    v.setFromMatrixColumn( objectMatrix, 0 );
                    v.multiplyScalar( - distance );
                    panOffset.add( v );
                };
            }();
            var panUp = function() {
                var v = new THREE.Vector3();
                return function panUp( distance, objectMatrix ) {
                    if ( scope.screenSpacePanning === true ) {
                        v.setFromMatrixColumn( objectMatrix, 1 );
                    } else {
                        v.setFromMatrixColumn( objectMatrix, 0 );
                        v.crossVectors( scope.object.up, v );
                    }
                    v.multiplyScalar( distance );
                    panOffset.add( v );
                };
            }();
            var pan = function() {
                var offset = new THREE.Vector3();
                return function pan( deltaX, deltaY ) {
                    var element = scope.domElement;
                    if ( scope.object.isPerspectiveCamera ) {
                        var position = scope.object.position;
                        offset.copy( position ).sub( scope.target );
                        var targetDistance = offset.length();
                        targetDistance *= Math.tan( ( scope.object.fov / 2 ) * Math.PI / 180.0 );
                        panLeft( 2 * deltaX * targetDistance / element.clientHeight, scope.object.matrix );
                        panUp( 2 * deltaY * targetDistance / element.clientHeight, scope.object.matrix );
                    } else if ( scope.object.isOrthographicCamera ) {
                        panLeft( deltaX * ( scope.object.right - scope.object.left ) / scope.object.zoom / element.clientWidth, scope.object.matrix );
                        panUp( deltaY * ( scope.object.top - scope.object.bottom ) / scope.object.zoom / element.clientHeight, scope.object.matrix );
                    } else {
                        console.warn( 'WARNING: OrbitControls.js encountered an unknown camera type - pan disabled.' );
                        scope.enablePan = false;
                    }
                };
            }();
            function dollyOut( dollyScale ) {
                if ( scope.object.isPerspectiveCamera ) {
                    scale /= dollyScale;
                } else if ( scope.object.isOrthographicCamera ) {
                    scope.object.zoom = Math.max( scope.minZoom, Math.min( scope.maxZoom, scope.object.zoom * dollyScale ) );
                    scope.object.updateProjectionMatrix();
                    zoomChanged = true;
                } else {
                    console.warn( 'WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.' );
                    scope.enableZoom = false;
                }
            }
            function dollyIn( dollyScale ) {
                if ( scope.object.isPerspectiveCamera ) {
                    scale *= dollyScale;
                } else if ( scope.object.isOrthographicCamera ) {
                    scope.object.zoom = Math.max( scope.minZoom, Math.min( scope.maxZoom, scope.object.zoom / dollyScale ) );
                    scope.object.updateProjectionMatrix();
                    zoomChanged = true;
                } else {
                    console.warn( 'WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.' );
                    scope.enableZoom = false;
                }
            }
            function handleMouseDownRotate( event ) {
                rotateStart.set( event.clientX, event.clientY );
            }
            function handleMouseDownDolly( event ) {
                dollyStart.set( event.clientX, event.clientY );
            }
            function handleMouseDownPan( event ) {
                panStart.set( event.clientX, event.clientY );
            }
            function handleMouseMoveRotate( event ) {
                rotateEnd.set( event.clientX, event.clientY );
                rotateDelta.subVectors( rotateEnd, rotateStart ).multiplyScalar( scope.rotateSpeed );
                var element = scope.domElement;
                rotateLeft( 2 * Math.PI * rotateDelta.x / element.clientHeight );
                rotateUp( 2 * Math.PI * rotateDelta.y / element.clientHeight );
                rotateStart.copy( rotateEnd );
                scope.update();
            }
            function handleMouseMoveDolly( event ) {
                dollyEnd.set( event.clientX, event.clientY );
                dollyDelta.subVectors( dollyEnd, dollyStart );
                if ( dollyDelta.y > 0 ) {
                    dollyOut( getZoomScale() );
                } else if ( dollyDelta.y < 0 ) {
                    dollyIn( getZoomScale() );
                }
                dollyStart.copy( dollyEnd );
                scope.update();
            }
            function handleMouseMovePan( event ) {
                panEnd.set( event.clientX, event.clientY );
                panDelta.subVectors( panEnd, panStart ).multiplyScalar( scope.panSpeed );
                pan( panDelta.x, panDelta.y );
                panStart.copy( panEnd );
                scope.update();
            }
            function handleMouseUp() {}
            function handleMouseWheel( event ) {
                if ( event.deltaY < 0 ) {
                    dollyIn( getZoomScale() );
                } else if ( event.deltaY > 0 ) {
                    dollyOut( getZoomScale() );
                }
                scope.update();
            }
            function handleKeyDown( event ) {
                var needsUpdate = false;
                switch ( event.keyCode ) {
                    case scope.keys.UP:
                        pan( 0, scope.keyPanSpeed );
                        needsUpdate = true;
                        break;
                    case scope.keys.BOTTOM:
                        pan( 0, - scope.keyPanSpeed );
                        needsUpdate = true;
                        break;
                    case scope.keys.LEFT:
                        pan( scope.keyPanSpeed, 0 );
                        needsUpdate = true;
                        break;
                    case scope.keys.RIGHT:
                        pan( - scope.keyPanSpeed, 0 );
                        needsUpdate = true;
                        break;
                }
                if ( needsUpdate ) {
                    event.preventDefault();
                    scope.update();
                }
            }
            function handleTouchStartRotate( event ) {
                if ( event.touches.length == 1 ) {
                    rotateStart.set( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY );
                } else {
                    var x = 0.5 * ( event.touches[ 0 ].pageX + event.touches[ 1 ].pageX );
                    var y = 0.5 * ( event.touches[ 0 ].pageY + event.touches[ 1 ].pageY );
                    rotateStart.set( x, y );
                }
            }
            function handleTouchStartPan( event ) {
                if ( event.touches.length == 1 ) {
                    panStart.set( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY );
                } else {
                    var x = 0.5 * ( event.touches[ 0 ].pageX + event.touches[ 1 ].pageX );
                    var y = 0.5 * ( event.touches[ 0 ].pageY + event.touches[ 1 ].pageY );
                    panStart.set( x, y );
                }
            }
            function handleTouchStartDolly( event ) {
                var dx = event.touches[ 0 ].pageX - event.touches[ 1 ].pageX;
                var dy = event.touches[ 0 ].pageY - event.touches[ 1 ].pageY;
                var distance = Math.sqrt( dx * dx + dy * dy );
                dollyStart.set( 0, distance );
            }
            function handleTouchStartDollyPan( event ) {
                if ( scope.enableZoom ) handleTouchStartDolly( event );
                if ( scope.enablePan ) handleTouchStartPan( event );
            }
            function handleTouchStartDollyRotate( event ) {
                if ( scope.enableZoom ) handleTouchStartDolly( event );
                if ( scope.enableRotate ) handleTouchStartRotate( event );
            }
            function handleTouchMoveRotate( event ) {
                if ( event.touches.length == 1 ) {
                    rotateEnd.set( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY );
                } else {
                    var x = 0.5 * ( event.touches[ 0 ].pageX + event.touches[ 1 ].pageX );
                    var y = 0.5 * ( event.touches[ 0 ].pageY + event.touches[ 1 ].pageY );
                    rotateEnd.set( x, y );
                }
                rotateDelta.subVectors( rotateEnd, rotateStart ).multiplyScalar( scope.rotateSpeed );
                var element = scope.domElement;
                rotateLeft( 2 * Math.PI * rotateDelta.x / element.clientHeight );
                rotateUp( 2 * Math.PI * rotateDelta.y / element.clientHeight );
                rotateStart.copy( rotateEnd );
            }
            function handleTouchMovePan( event ) {
                if ( event.touches.length == 1 ) {
                    panEnd.set( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY );
                } else {
                    var x = 0.5 * ( event.touches[ 0 ].pageX + event.touches[ 1 ].pageX );
                    var y = 0.5 * ( event.touches[ 0 ].pageY + event.touches[ 1 ].pageY );
                    panEnd.set( x, y );
                }
                panDelta.subVectors( panEnd, panStart ).multiplyScalar( scope.panSpeed );
                pan( panDelta.x, panDelta.y );
                panStart.copy( panEnd );
            }
            function handleTouchMoveDolly( event ) {
                var dx = event.touches[ 0 ].pageX - event.touches[ 1 ].pageX;
                var dy = event.touches[ 0 ].pageY - event.touches[ 1 ].pageY;
                var distance = Math.sqrt( dx * dx + dy * dy );
                dollyEnd.set( 0, distance );
                dollyDelta.set( 0, Math.pow( dollyEnd.y / dollyStart.y, scope.zoomSpeed ) );
                dollyOut( dollyDelta.y );
                dollyStart.copy( dollyEnd );
            }
            function handleTouchMoveDollyPan( event ) {
                if ( scope.enableZoom ) handleTouchMoveDolly( event );
                if ( scope.enablePan ) handleTouchMovePan( event );
            }
            function handleTouchMoveDollyRotate( event ) {
                if ( scope.enableZoom ) handleTouchMoveDolly( event );
                if ( scope.enableRotate ) handleTouchMoveRotate( event );
            }
            function handleTouchEnd() {}
            var twoPI = 2 * Math.PI;
            function onPointerDown( event ) {
                if ( scope.enabled === false ) return;
                if ( event.pointerType === 'touch' ) {
                    onTouchStart( event );
                } else {
                    onMouseDown( event );
                }
            }
            function onPointerMove( event ) {
                if ( scope.enabled === false ) return;
                if ( event.pointerType === 'touch' ) {
                    onTouchMove( event );
                } else {
                    onMouseMove( event );
                }
            }
            function onPointerUp( event ) {
                if ( scope.enabled === false ) return;
                if ( event.pointerType === 'touch' ) {
                    onTouchEnd( event );
                } else {
                    onMouseUp( event );
                }
            }
            function onMouseDown( event ) {
                var mouseAction;
                switch ( event.button ) {
                    case 0:
                        mouseAction = scope.mouseButtons.LEFT;
                        break;
                    case 1:
                        mouseAction = scope.mouseButtons.MIDDLE;
                        break;
                    case 2:
                        mouseAction = scope.mouseButtons.RIGHT;
                        break;
                    default:
                        mouseAction = - 1;
                }
                switch ( mouseAction ) {
                    case THREE.MOUSE.DOLLY:
                        if ( scope.enableZoom === false ) return;
                        handleMouseDownDolly( event );
                        state = STATE.DOLLY;
                        break;
                    case THREE.MOUSE.ROTATE:
                        if ( event.ctrlKey || event.metaKey || event.shiftKey ) {
                            if ( scope.enablePan === false ) return;
                            handleMouseDownPan( event );
                            state = STATE.PAN;
                        } else {
                            if ( scope.enableRotate === false ) return;
                            handleMouseDownRotate( event );
                            state = STATE.ROTATE;
                        }
                        break;
                    case THREE.MOUSE.PAN:
                        if ( event.ctrlKey || event.metaKey || event.shiftKey ) {
                            if ( scope.enableRotate === false ) return;
                            handleMouseDownRotate( event );
                            state = STATE.ROTATE;
                        } else {
                            if ( scope.enablePan === false ) return;
                            handleMouseDownPan( event );
                            state = STATE.PAN;
                        }
                        break;
                    default:
                        state = STATE.NONE;
                }
                if ( state !== STATE.NONE ) {
                    scope.domElement.ownerDocument.addEventListener( 'pointermove', onPointerMove, false );
                    scope.domElement.ownerDocument.addEventListener( 'pointerup', onPointerUp, false );
                    scope.dispatchEvent( startEvent );
                }
            }
            function onMouseMove( event ) {
                if ( scope.enabled === false ) return;
                event.preventDefault();
                switch ( state ) {
                    case STATE.ROTATE:
                        if ( scope.enableRotate === false ) return;
                        handleMouseMoveRotate( event );
                        break;
                    case STATE.DOLLY:
                        if ( scope.enableZoom === false ) return;
                        handleMouseMoveDolly( event );
                        break;
                    case STATE.PAN:
                        if ( scope.enablePan === false ) return;
                        handleMouseMovePan( event );
                        break;
                }
            }
            function onMouseUp( event ) {
                if ( scope.enabled === false ) return;
                handleMouseUp( event );
                scope.domElement.ownerDocument.removeEventListener( 'pointermove', onPointerMove, false );
                scope.domElement.ownerDocument.removeEventListener( 'pointerup', onPointerUp, false );
                scope.dispatchEvent( endEvent );
                state = STATE.NONE;
            }
            function onMouseWheel( event ) {
                if ( scope.enabled === false || scope.enableZoom === false || ( state !== STATE.NONE && state !== STATE.ROTATE ) ) return;
                event.preventDefault();
                event.stopPropagation();
                scope.dispatchEvent( startEvent );
                handleMouseWheel( event );
                scope.dispatchEvent( endEvent );
            }
            function onKeyDown( event ) {
                if ( scope.enabled === false || scope.enableKeys === false || scope.enablePan === false ) return;
                handleKeyDown( event );
            }
            function onTouchStart( event ) {
                if ( scope.enabled === false ) return;
                event.preventDefault();
                switch ( event.touches.length ) {
                    case 1:
                        switch ( scope.touches.ONE ) {
                            case THREE.TOUCH.ROTATE:
                                if ( scope.enableRotate === false ) return;
                                handleTouchStartRotate( event );
                                state = STATE.TOUCH_ROTATE;
                                break;
                            case THREE.TOUCH.PAN:
                                if ( scope.enablePan === false ) return;
                                handleTouchStartPan( event );
                                state = STATE.TOUCH_PAN;
                                break;
                            default:
                                state = STATE.NONE;
                        }
                        break;
                    case 2:
                        switch ( scope.touches.TWO ) {
                            case THREE.TOUCH.DOLLY_PAN:
                                if ( scope.enableZoom === false && scope.enablePan === false ) return;
                                handleTouchStartDollyPan( event );
                                state = STATE.TOUCH_DOLLY_PAN;
                                break;
                            case THREE.TOUCH.DOLLY_ROTATE:
                                if ( scope.enableZoom === false && scope.enableRotate === false ) return;
                                handleTouchStartDollyRotate( event );
                                state = STATE.TOUCH_DOLLY_ROTATE;
                                break;
                            default:
                                state = STATE.NONE;
                        }
                        break;
                    default:
                        state = STATE.NONE;
                }
                if ( state !== STATE.NONE ) {
                    scope.dispatchEvent( startEvent );
                }
            }
            function onTouchMove( event ) {
                if ( scope.enabled === false ) return;
                event.preventDefault();
                switch ( state ) {
                    case STATE.TOUCH_ROTATE:
                        if ( scope.enableRotate === false ) return;
                        handleTouchMoveRotate( event );
                        scope.update();
                        break;
                    case STATE.TOUCH_PAN:
                        if ( scope.enablePan === false ) return;
                        handleTouchMovePan( event );
                        scope.update();
                        break;
                    case STATE.TOUCH_DOLLY_PAN:
                        if ( scope.enableZoom === false && scope.enablePan === false ) return;
                        handleTouchMoveDollyPan( event );
                        scope.update();
                        break;
                    case STATE.TOUCH_DOLLY_ROTATE:
                        if ( scope.enableZoom === false && scope.enableRotate === false ) return;
                        handleTouchMoveDollyRotate( event );
                        scope.update();
                        break;
                    default:
                        state = STATE.NONE;
                }
            }
            function onTouchEnd( event ) {
                if ( scope.enabled === false ) return;
                handleTouchEnd( event );
                scope.dispatchEvent( endEvent );
                state = STATE.NONE;
            }
            function onContextMenu( event ) {
                if ( scope.enabled === false ) return;
                event.preventDefault();
            }
            scope.domElement.addEventListener( 'contextmenu', onContextMenu, false );
            scope.domElement.addEventListener( 'pointerdown', onPointerDown, false );
            scope.domElement.addEventListener( 'wheel', onMouseWheel, false );
            scope.domElement.addEventListener( 'touchstart', onTouchStart, false );
            scope.domElement.addEventListener( 'touchend', onTouchEnd, false );
            scope.domElement.addEventListener( 'touchmove', onTouchMove, false );
            scope.domElement.addEventListener( 'keydown', onKeyDown, false );
            if ( scope.domElement.style ) {
                scope.domElement.style.touchAction = 'none';
            }
            this.update();
        };
        THREE.OrbitControls.prototype = Object.create( THREE.EventDispatcher.prototype );
        THREE.OrbitControls.prototype.constructor = THREE.OrbitControls;
    </script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>
    <script src="js/food_explorer_3d.js"></script>
</body>
</html> 